'''
https://www.zhihu.com/question/20122137

#----------------------------#



'''

import time
from termcolor import colored



def main_process():
    t = '''
@ 1.epoll 或者 kqueue 的原理是什么？
简单的说，就是一个生产者，消费者的方式。底层生成数据，放到readylist，用户用epoll_wait去取。

epoll用红黑树存储，用list存储就绪事件（与select和poll不同，select是bitmap，poll是数组存储），
之所以是e-poll，是因为它是event事件驱动，也就是说就通知这方面而言是异步的，
但是unp中仍然将epoll定义为同步的多路复用io模型，因此在很多地方epoll又有人称为伪异步。

2. 边缘计算？
边缘计算最开始，是因为传统海量数据传输非常费资源，且数据频率和数据质量都会受大量数据传输影响。
这里举一个不严谨的例子：比如我们想算个加速度，可是由于某些原因无法安装MPU6050类似的元件，只能通过速度求导，
可数据上传到云端之后再计算，已经面目全非了，缺失的、误码的、时间频率不均匀的，想计算精确的加速度较为困难。
于是人们就想，能不能把海量数据中这些速度的时间序列先进行一级计算，再将计算结果传到云端，这样既快速，又可靠。恩，这就是边缘计算了。

3.tcp粘包？
是否会出现粘包, 这个取决于你发送的图片大小,以及每次发送的包大小，以及发送的频率。
比如有以下几种情况：你只需要发送一张图片，那么直接将文件加载到内存，当成一个完整的数据流发送，发送完成后关闭后即可。
这种情况都不需要分包发送；也不用考虑粘包的问题，因为不论怎么粘，这块数据他就是完整的。
在很多情况下，我们需要发送多个图片，而且是连续发送的，那么这种情况就存在粘包的问题，
比如图片1的尾部数据和图片2的头部数据粘在一起，发送到了接收端。这时候接收端如果直接readall，并保存为文件，那么很显然，
结果就错了，图片1和图片2 都是错的。

解决办法就是：定义包结构；一般可以定义为 包头+包体；包头一般定长，并且至少包含了文件大小字段；包体就是发送文件的二进制数据； 
接收端一定是先收到包头，解析包头中的文件大小字段后，继续接收文件大小规定的包数据，读不够继续等待，
如果超长，说明读到了下一个文件或数据包的内容， 应该缓存起来，给下个包使用。等到读取到了指定大小的包后，
数据就已经是完整的。也有人采用特殊包尾的方式来作为粘包切割的依据，但这种方法不太精确，如果发送内容中包含特殊包尾就会出错。


    '''
    print(t)

if __name__ == "__main__":
    tic = time.process_time()
    
    main_process()

    toc = time.process_time()
    print("time=",toc - tic)





