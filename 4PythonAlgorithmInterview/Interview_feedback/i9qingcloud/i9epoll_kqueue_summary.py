'''
https://www.zhihu.com/question/20122137

#----------------------------#



'''

import time
from termcolor import colored



def main_process():
    t = '''
@ 1.epoll 或者 kqueue 的原理是什么？
简单的说，就是一个生产者，消费者的方式。底层生成数据，放到readylist，用户用epoll_wait去取。

epoll用红黑树存储，用list存储就绪事件（与select和poll不同，select是bitmap，poll是数组存储），
之所以是e-poll，是因为它是event事件驱动，也就是说就通知这方面而言是异步的，
但是unp中仍然将epoll定义为同步的多路复用io模型，因此在很多地方epoll又有人称为伪异步。


https://zhuanlan.zhihu.com/p/39970630
epoll被内核初始化时（操作系统启动)，同时开辟epoll自己的内核高速cache区，安置每一个我们想监控的socket
这些socket以红黑树形式存在内核cache 以支持快速的查找、插入、删除。这个内核高速cache区，就是建立连续的物理内存页，
然后在之上建立slab层，简单的说，就是物理上分配好你想要的size的内存对象，每次使用时都是使用空闲的已分配好的对象。

epoll的高效就在于，当我们调用epoll_ctl往里塞入百万个句柄时，epoll_wait仍然可以飞快的返回，并有效的将发生事件的句柄给我们用户。
这是由于我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于
存储以后epoll_ctl传来的socket外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，
仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。
所以，epoll_wait非常高效。

而且，通常情况下即使我们要监控百万计的句柄，大多一次也只返回很少量的准备就绪句柄而已，
所以，epoll_wait仅需要从内核态copy少量的句柄到用户态而已，如何能不高效？！

那么，这个准备就绪list链表是怎么维护的呢？当我们执行epoll_ctl时，除了把socket放到epoll文件系统里file对象对应的红黑树上之外，
还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。
所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了。

如此，一颗红黑树，一张准备就绪句柄链表，少量的内核cache，就帮我们解决了大并发下的socket处理问题。
执行epoll_create时，创建了红黑树和就绪链表，执行epoll_ctl时，如果增加socket句柄，
则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，
用于当中断事件来临时向准备就绪链表中插入数据。执行epoll_wait时立刻返回准备就绪链表里的数据即可。

2. 边缘计算？
边缘计算最开始，是因为传统海量数据传输非常费资源，且数据频率和数据质量都会受大量数据传输影响。
这里举一个不严谨的例子：比如我们想算个加速度，可是由于某些原因无法安装MPU6050类似的元件，只能通过速度求导，
可数据上传到云端之后再计算，已经面目全非了，缺失的、误码的、时间频率不均匀的，想计算精确的加速度较为困难。
于是人们就想，能不能把海量数据中这些速度的时间序列先进行一级计算，再将计算结果传到云端，这样既快速，又可靠。恩，这就是边缘计算了。

3.tcp粘包？
是否会出现粘包, 这个取决于你发送的图片大小,以及每次发送的包大小，以及发送的频率。
比如有以下几种情况：你只需要发送一张图片，那么直接将文件加载到内存，当成一个完整的数据流发送，发送完成后关闭后即可。
这种情况都不需要分包发送；也不用考虑粘包的问题，因为不论怎么粘，这块数据他就是完整的。
在很多情况下，我们需要发送多个图片，而且是连续发送的，那么这种情况就存在粘包的问题，
比如图片1的尾部数据和图片2的头部数据粘在一起，发送到了接收端。这时候接收端如果直接readall，并保存为文件，那么很显然，
结果就错了，图片1和图片2 都是错的。

解决办法就是：定义包结构；一般可以定义为 包头+包体；包头一般定长，并且至少包含了文件大小字段；包体就是发送文件的二进制数据； 
接收端一定是先收到包头，解析包头中的文件大小字段后，继续接收文件大小规定的包数据，读不够继续等待，
如果超长，说明读到了下一个文件或数据包的内容， 应该缓存起来，给下个包使用。等到读取到了指定大小的包后，
数据就已经是完整的。也有人采用特殊包尾的方式来作为粘包切割的依据，但这种方法不太精确，如果发送内容中包含特殊包尾就会出错。


    '''
    print(t)

if __name__ == "__main__":
    tic = time.process_time()
    
    main_process()

    toc = time.process_time()
    print("time=",toc - tic)





